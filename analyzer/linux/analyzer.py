import os
import logging
import xmlrpclib
import subprocess
from datetime import datetime

from lib.common.constants import PATHS
from lib.core.config import Config
from lib.core.startup import init_logging

log = logging.getLogger()

class Analyzer(object):
    def __init__(self):
        self.config = None
        self.target = None

    def prepare(self):
        # Initialize logging.
        init_logging()

        # Parse the analysis configuration file generated by the agent.
        self.config = Config(cfg="analysis.conf")
        
        # Set virtual machine clock
        clock = datetime.strptime(self.config.clock, "%Y%m%dT%H:%M:%S")
        
        # Set date and time
        # And disable stdout using '/dev/null 2>&1'
        os.system("date -s '{0}' > /dev/null 2>&1".format(clock))

        # We update the target according to its category. If it's a file, then
        # we store the path.
        if self.config.category == "file":
            self.target = os.path.join("/tmp", str(self.config.file_name))
        # If it's a URL, well.. we store the URL.
        else:
            self.target = self.config.target

    def run(self):
        self.prepare()

        log.info("Starting analyzer from: {0}".format(os.getcwd()))
        log.info("Storing results at: {0}".format(PATHS["root"]))
        log.info("Target is: {0}".format(self.target))

        if self.config.category == "file":
            subprocess.call(["sh", self.target], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        return True

if __name__ == "__main__":
    success = False
    error = ""

    try:
        # Initialize the main analyzer class.
        analyzer = Analyzer()
        # Run it and wait for the response.
        success = analyzer.run()
    # This is not likely to happen.
    except KeyboardInterrupt:
        error = "Keyboard Interrupt"
    # If the analysis process encountered a critical error, it will raise a
    # CuckooError exception, which will force the termination of the analysis
    # weill notify the agent of the failure. Also catched unexpected
    # exceptions.
    except Exception as e:
        # Store the error.
        error = str(e)

        # Just to be paranoid.
        if len(log.handlers) > 0:
            log.critical(error)
        else:
            sys.stderr.write("{0}\n".format(e))
    # Once the analysis is completed or terminated for any reason, we report
    # back to the agent, notifying that it can report back to the host.
    finally:
        # Establish connection with the agent XMLRPC server.
        server = xmlrpclib.Server("http://127.0.0.1:8000")
        server.complete(success, error, PATHS["root"])
